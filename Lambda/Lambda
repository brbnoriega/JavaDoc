Buenas! investigando sobre las expresiones lambda descubr√≠ que sirven para implementar de manera r√°pida y concisa interfaces funcionales. La sintaxis b√°sica ser√≠a (parametro) -> {cuerpo}, donde la funci√≥n an√≥nima puede o no recibir par√°metros. 

üëâ La expresi√≥n lambda debe estar asociada a una interfaz funcional que define el m√©todo que la expresi√≥n lambda va a implementar. Esto facilita la escritura de funciones de orden superior y el uso de programaci√≥n funcional en general. Por ejemplo:

//declaro la interface como metodo abstracto
interface Aviso{
    void saludar();
};
public class Lambda {
    public static void main(String[] args) {
        // expresi√≥n lambda para saludar
        Aviso ganador= () -> System.out.println("Primero llego Yoshi!");
        ganador.saludar();
    }}

üëâ En este caso, no use ning√∫n par√°metro, pero ¬øqu√© sucede si necesitamos uno o m√°s? La sintaxis ser√≠a la siguiente: con un par√°metro, (param) -> {cuerpo} y con m√∫ltiples par√°metros (param1, param2) -> {cuerpo}. Por ejemplo:

interface Puntaje {
    void registrarPuntaje(String piloto, int puntaje);
}
public class Lambda {
    public static void main(String[] args) {
      
        Puntaje registrarPuntaje = (piloto, puntaje) -> System.out.println(piloto + " ha obtenido un puntaje de " + puntaje + " puntos");

        registrarPuntaje.registrarPuntaje("Mario", 25); 
        registrarPuntaje.registrarPuntaje("Luigi", 18);     
}}

üéØ El uso de estas expresiones puede variar seg√∫n la necesidad de uso

https://postimg.cc/3yd2QxwK

Y como se integra lambda con colecciones? Y  con streams?Tomemos como ejemplo una clase Pelicula con atributos de t√≠tulo, fecha y genero. 

Luego creamos las pelis üçø  (vos que peli agregar√≠as?) :
        
List<Pelicula> peliculas = Arrays.asList(
            new Pelicula("Gladiador", 2000, "Acci√≥n"),
            new Pelicula("El Padrino", 1972, "Drama"),
            new Pelicula("La Milla Verde", 1999, "Drama"),
            new Pelicula("El Se√±or de los Anillos", 2001, "Fantas√≠a")
        );

Y realizo las siguientes operaciones:
// Filtrado por g√©nero
        List<Pelicula> peliculasDramaticas = peliculas.stream() //elemento
                .filter(pelicula -> pelicula.getGenero().equals("Drama"))
                .collect(Collectors.toList()); // crea la lista
        System.out.println("Pel√≠culas de drama: " + peliculasDramaticas );


// Mapeo de t√≠tulos
        List<String> titulos = peliculas.stream() // convierte la lista a elemento
                .map(Pelicula::getTitulo) //operador :: alude a m√©todo existente
                .collect(Collectors.toList()); //recopila la lista
        System.out.println("T√≠tulos de las pel√≠culas: " + titulos);


// B√∫squeda por fecha m√°s antigua
        int fechaMasAntigua = peliculas.stream()
                .mapToInt(Pelicula::getFecha) //transforma cada objeto Pelicula en su a√±o como un entero
                .min() //m√©todo para encontrar el valor m√≠nimo
       .getAsInt(); // extrae y almacena el valor en fechaMasAntigua
     
        System.out.println("Fecha m√°s antigua: " + fechaMasAntigua);

La combinaci√≥n de lambda con streams proporciona un enfoque funcional para interactuar con datos. En conjunto nos permiten definir funciones an√≥nimas de forma concisa. 
